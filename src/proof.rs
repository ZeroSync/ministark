use crate::fri::FriProof;
use crate::merkle::MerkleTree;
use crate::random::PublicCoin;
use crate::stark::Stark;
use crate::trace::Queries;
use crate::utils::field_bits;
use crate::ProofOptions;
use ark_serialize::CanonicalDeserialize;
use ark_serialize::CanonicalSerialize;
use ark_serialize::Valid;

/// A proof generated by a mini-stark prover
pub struct Proof<C: Stark> {
    pub options: ProofOptions,
    pub trace_len: usize,
    pub base_trace_commitment: C::Digest,
    pub extension_trace_commitment: Option<C::Digest>,
    pub composition_trace_commitment: C::Digest,
    pub fri_proof: FriProof<C::Fq, C::Digest, C::MerkleTree>,
    pub pow_nonce: u64,
    pub trace_queries: Queries<C>,
    pub execution_trace_ood_evals: Vec<C::Fq>,
    pub composition_trace_ood_evals: Vec<C::Fq>,
}

impl<C: Stark> Clone for Proof<C> {
    fn clone(&self) -> Self {
        Self {
            options: self.options,
            trace_len: self.trace_len,
            base_trace_commitment: self.base_trace_commitment.clone(),
            extension_trace_commitment: self.extension_trace_commitment.clone(),
            composition_trace_commitment: self.composition_trace_commitment.clone(),
            fri_proof: self.fri_proof.clone(),
            pow_nonce: self.pow_nonce,
            trace_queries: self.trace_queries.clone(),
            execution_trace_ood_evals: self.execution_trace_ood_evals.clone(),
            composition_trace_ood_evals: self.composition_trace_ood_evals.clone(),
        }
    }
}

impl<C: Stark> CanonicalSerialize for Proof<C> {
    fn serialize_with_mode<W: ark_serialize::Write>(
        &self,
        mut writer: W,
        compress: ark_serialize::Compress,
    ) -> Result<(), ark_serialize::SerializationError> {
        self.options.serialize_with_mode(&mut writer, compress)?;
        self.trace_len.serialize_with_mode(&mut writer, compress)?;
        self.base_trace_commitment
            .serialize_with_mode(&mut writer, compress)?;
        self.extension_trace_commitment
            .serialize_with_mode(&mut writer, compress)?;
        self.composition_trace_commitment
            .serialize_with_mode(&mut writer, compress)?;
        self.fri_proof.serialize_with_mode(&mut writer, compress)?;
        self.pow_nonce.serialize_with_mode(&mut writer, compress)?;
        self.trace_queries
            .serialize_with_mode(&mut writer, compress)?;
        self.execution_trace_ood_evals
            .serialize_with_mode(&mut writer, compress)?;
        self.composition_trace_ood_evals
            .serialize_with_mode(&mut writer, compress)?;
        Ok(())
    }

    fn serialized_size(&self, compress: ark_serialize::Compress) -> usize {
        self.options.serialized_size(compress)
            + self.trace_len.serialized_size(compress)
            + self.base_trace_commitment.serialized_size(compress)
            + self.extension_trace_commitment.serialized_size(compress)
            + self.composition_trace_commitment.serialized_size(compress)
            + self.fri_proof.serialized_size(compress)
            + self.pow_nonce.serialized_size(compress)
            + self.trace_queries.serialized_size(compress)
            + self.execution_trace_ood_evals.serialized_size(compress)
            + self.composition_trace_ood_evals.serialized_size(compress)
    }
}

impl<C: Stark> Valid for Proof<C> {
    #[inline]
    fn check(&self) -> Result<(), ark_serialize::SerializationError> {
        Ok(())
    }
}

impl<C: Stark> CanonicalDeserialize for Proof<C> {
    fn deserialize_with_mode<R: ark_serialize::Read>(
        mut reader: R,
        compress: ark_serialize::Compress,
        validate: ark_serialize::Validate,
    ) -> Result<Self, ark_serialize::SerializationError> {
        Ok(Self {
            options: <_>::deserialize_with_mode(&mut reader, compress, validate)?,
            trace_len: <_>::deserialize_with_mode(&mut reader, compress, validate)?,
            base_trace_commitment: <_>::deserialize_with_mode(&mut reader, compress, validate)?,
            extension_trace_commitment: <_>::deserialize_with_mode(
                &mut reader,
                compress,
                validate,
            )?,
            composition_trace_commitment: <_>::deserialize_with_mode(
                &mut reader,
                compress,
                validate,
            )?,
            fri_proof: <_>::deserialize_with_mode(&mut reader, compress, validate)?,
            pow_nonce: <_>::deserialize_with_mode(&mut reader, compress, validate)?,
            trace_queries: <_>::deserialize_with_mode(&mut reader, compress, validate)?,
            execution_trace_ood_evals: <_>::deserialize_with_mode(&mut reader, compress, validate)?,
            composition_trace_ood_evals: <_>::deserialize_with_mode(
                &mut reader,
                compress,
                validate,
            )?,
        })
    }
}

impl<C: Stark> Proof<C> {
    // adapted from Winterfell
    // also https://github.com/starkware-libs/ethSTARK/blob/master/README.md#7-Measuring-Security
    // https://eprint.iacr.org/2020/654.pdf section 7.2 for proven security
    pub fn security_level_bits(&self) -> u32 {
        let field_security = {
            let lde_domain_size = self.trace_len * self.options.lde_blowup_factor as usize;
            let extension_field_bits = field_bits::<C::Fq>();
            extension_field_bits - lde_domain_size.ilog2()
        };

        let fri_query_security = {
            let grinding_factor = u32::from(self.options.grinding_factor);
            let security_per_query = self.options.lde_blowup_factor.ilog2();
            let num_fri_quiries = u32::from(self.options.num_queries);
            security_per_query * num_fri_quiries + grinding_factor
        };

        let merkle_tree_security = C::MerkleTree::security_level_bits();
        let public_coin_security = C::PublicCoin::security_level_bits();

        field_security
            .min(fri_query_security)
            .min(merkle_tree_security)
            .min(public_coin_security)
    }
}
